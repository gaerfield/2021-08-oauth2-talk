<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>dezentrale Authentifizierung mit OAuth 2</title>
    <link rel="shortcut icon" href="./favicon.ico"/>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./_assets/custom.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

# dezentrale Authentifizierung mit OAuth 2

</script></section><section ><section data-markdown><script type="text/template">
## Ziel

Dezentrales Authentifizierungssystem für webbasierte Dienste.

* OAuth als Protokoll zur Authentifizierung für die Autorisierung von Zugriffsrechten zwischen zwei Applikationen
* OpenID Connect aufbauend auf OAuth erlaubt die Wiederverwendung desselben Logins für verschiedene Applikationen (Single-Sign-On) und den standardisierten Abruf von Profilinformationen

</script></section><section data-markdown><script type="text/template">
## Geschichte I

* 2005 OpenID Vorstellung des offenen Single-Sign-On Protokolls
* 2006 Entwicklung von OAuth 1.0 während der Integration von OpenID in Twitter (Delegation der Authentifizierung)
* 2007 Vorstellung von OAuth 1.0
* Juni 2007 Gründung der OpenID Foundation zur Sicherung von Markenrechten

</script></section><section data-markdown><script type="text/template">
## Geschichte I

* Dezember 2007 OpenID 2.0
* November 2008 Vorschlag an die IETF zur Standardisierung von OAuth
* 2012 OAuth 2 durch die IETF als RFC 6749 und RFC 6750 veröffentlicht.
* irgendwann OpenID Connect als Schicht oberhalb des OAuth Protokolls


</script></section><section data-markdown><script type="text/template">
## Startup s0ft-fit

* 1 Fitnessstudio
* USP: bieten online Training-Tracker

> Gehe Trainieren wann immer du willst!
> Rufe deine Trainings-Historie ab wann immer du willst!

</script></section><section data-markdown><script type="text/template">
### Architektur

<img src='https://g.gravizo.com/svg?@startuml;node server {;component "s0ft-fit.de";};@enduml'/>

</script></section><section data-markdown><script type="text/template">
### Typischer Flow der Authentifizierung
<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "server";user -> webclient++ : login bei "s0ft-fit.de";webclient -> server++ : login;server -> server : validiere;return ok;return willkommen;@enduml'/>

</script></section></section><section ><section data-markdown><script type="text/template">
## Modularisierung von s0ft-fit

</script></section><section data-markdown><script type="text/template">
### Problemstellung

* wir haben expandiert, auf tausende Fitnessstudios
* Login und Historie sind unterschiedlich stark frequentiert und sollen unabhängig skalieren um Ressourcen zu sparen
* Wie überprüft die Historie:
  * zu welchem Nutzer die Anfrage gehört?
  * ob der Nutzer sich korrekt authentifiziert hat?
  * klasssicher Ansatz: sessions

</script></section><section data-markdown><script type="text/template">
#### Login erzeugt Session

<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "login";database "session-management" as ses;;user -> webclient++ : login bei "s0ftf1t.de";webclient -> login++ : login;login -> login : validiere;login -> ses++ : loggedIn(User);ses -> ses : lege session an und speichere User;return sessionId;return sessionId;return willkommen;@enduml'/>

</script></section><section data-markdown><script type="text/template">
#### SessionId

Die `sessionId` ist ein inhaltsloses zeitlich eingeschränkt gültiges Token welches das Backend zu einem konkreten Nutzer zugeordnet hat.

</script></section><section data-markdown><script type="text/template">
#### Abruf der Historie

<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "bankdruecken-historie" as his;participant "login";database "session-management" as ses;;user -> webclient++ : Klick auf Historie;webclient -> his++ : getFor(sessionId);his -> login++ : getUserForSession(sessionId);login -> ses++ : sessionId;return User;return User;his -> his : getFor(User);return history;return tabelle;@enduml'/>

</script></section><section data-markdown><script type="text/template">
#### Abruf der Historie

* Backend fragt erneut immer wieder die Login-Komponente an
  * Auslastung der Login-Komponente vervielfacht sich mit Auslastung Backends
  * Antwortzeiten des Backends erhöhen sich um Antwortzeit der login-Komponente
  * gute Skalierung, schnelle Datenbank und evtl. globales Caching notwendig

</script></section><section data-markdown><script type="text/template">
#### stateless Tokens

* Sessions sind ideal für temporäre Datenbestände wie Warenkörbe
* eine `UserId` ändert sich nicht während seiner Zugriffs
* Können wir die `UserId` statt der `sessionId` liefern und sicherstellen, dass diese nicht vom Nutzer verändert wurde?

</script></section><section data-markdown><script type="text/template">
### Token

<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "login";participant "bankdruecken-historie" as his;;user -> webclient++ : login bei "s0ftf1t.de";webclient -> login++ : login;login -> login : validiere;return User=Achim;return willkommen;...;user -> webclient++ : Klick auf Historie;webclient -> his++ : getFor(user = Achim);return history;return tabelle;@enduml'/>

</script></section><section data-markdown><script type="text/template">
#### JSON Web Token (JWT)

JWT ist ein RFC-Standard ([RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)) zum Austausch von **verifizierbaren** Informationen.

> JWT's eignen sich [...] zur Implemen-tierung von "stateless sessions", da sämtliche authentifizierungsrelevanten Informationen im Token übertragen werden können und die Sitzung nicht zusätzlich auf einem Server gespeichert werden muss.

Quelle: [wikipedia](https://de.wikipedia.org/w/index.php?title=JSON_Web_Token&oldid=212574521)

</script></section><section data-markdown><script type="text/template">
#### JWT

* Aufbau eines JWT-Token:
  * `base64(Header).base64(Payload).signature`
  * Header: unter anderem den Signatur-Algorithmus
  * Payload: sog. "claims", die verifizierbaren Entitäten
  * Signatur: hash des Klartexts aus header und payload entsprechend des im Header angegebenen Algorithmus
  * Beispiel: [jwt.io](https://jwt.io)

</script></section><section data-markdown><script type="text/template">
### JWT Ausstellung

<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "login";;user -> webclient++ : login bei "s0ftf1t.de";webclient -> login++ : login;login -> login : validiere;login -> login : erzeuge JWT;login -> login : signiere JWT mittels\n**private-key**;return --User-- **JWT**;return willkommen;@enduml'/>

</script></section><section data-markdown><script type="text/template">
### JWT Nutzung

<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "bankdruecken-historie" as his;;user -> webclient++ : Klick auf Historie;webclient -> his++ : getFor(--User-- **JWT**);his -> his : validiere Signatur mittels\n**public-key**;return history;return tabelle;@enduml'/>

</script></section><section data-markdown><script type="text/template">
### Fazit

In einem verteilten System ist eine zentrale Authentifikations-Instanz welche JWT-Tokens ausstellt hinreichend.

<img src='https://g.gravizo.com/svg?@startuml;left to right direction;;component webclient;;cloud "s0ft-fit" {;component Login;note right of [Login];erstellt und signiert;Auth-Token (JWT);end note;component "bankdruecken-historie" as his;note right of [his];prüft Signatur;des Auth-Token;;end note;;webclient --> Login: einloggen;webclient --> his : Historie abrufen\nmit JWT im Header;webclient <-- Login : liefert Auth-Token (JWT);;his -> Login : ruft public key ab;};;;;@enduml'/>

</script></section></section><section ><section data-markdown><script type="text/template">
## Öffnung von s0ft-fit für Drittanwendungen

</script></section><section data-markdown><script type="text/template">
### FitX-App will unsere Daten

* s0ft-fit ist riesig geworden
* europaweit verteilt, 500 Studios, unzählige Angestellte, eine App
* die Tracker-App FitX möchte unsere Daten in ihre App für statistische Auswertungen integrieren
  * Besser: wir erlauben potentiell allen Fitness-Trackern die Nutzung unserer API um mehr Kunden zu gewinnen.

</script></section><section data-markdown><script type="text/template">
### Problemstellung

* Wie erlauben wir Drittanwendungen den Zugriff auf unsere Api?
* Wie beschränken wir den Zugriff der Drittanwendungen nur auf die Daten dessen Nutzer diese auch tatsächlich weiterreichen möchten?

</script></section><section data-markdown><script type="text/template">
### OAuth

> Ein Endbenutzer kann mit Hilfe von OAuth einer Anwendung den Zugriff auf seine Daten erlauben, die von einem anderen Dienst bereitgestellt werden, ohne geheime Details seiner Zugangsberechtigung preiszugeben.

Quelle: [wikipedia](https://de.wikipedia.org/w/index.php?title=OAuth&oldid=212703586)

</script></section><section data-markdown><script type="text/template">
#### Beispiel Github

* [Gitub - creating an oauth app](https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app)

</script></section><section data-markdown><script type="text/template">
#### OAuth Grundbegriffe I

* Resource Owner: Benutzer (der Zugriff auf seine Daten gewährt)
* Resource Server: Dienst auf dem die geschützten Resourcen liegen
* Client: Drittanwendung, die Zugriff auf die Daten möchte
* Authorization Server: der Server, der den _Resource Owner_ authentifiziert und _Access Token_ und _Refresh Token_  ausstellt
* Consent: die explizite Zustimmung des _Resource Owner_ ob sie dem _Client_ die angefragten Scopes gewähren

</script></section><section data-markdown><script type="text/template">
#### OAuth Grundbegriffe II

* Access Token: kurzlebiges geheimes Token, mittels dessen Resourcen beim _Resource Server_ im Namen des _Resource Owner_ abgerufen werden können
* Refresh Token: "langlebiges" geheimes Token mittels dem neue _Access Token_ beim _Authorization Server_ abgerufen werden können ohne sich erneut authentifizieren zu müssen
* Scope: feingranulare Zugriffsrechte die durch den _Client_ angefragt werden

</script></section><section data-markdown><script type="text/template">
#### Warum Access-Token und Refresh-Token?

* Access-Token werden für den Zugriff auf den Resource-Server verwendet und werden häufig für verschiedenste Anfragen wiederverwendet
* Refresh-Token verbleiben beim Client und werden ausschließlich für die Ausstellung neuer Access-Token verwendet
* Access-Token sind dadurch potentiell leichter abgreifbar als Refresh-Token, durch die kurze Gültigkeit ist der Schaden aber begrenzt

</script></section><section data-markdown><script type="text/template">
#### der Oauth-Flow am Beispiel Github
<img src='https://g.gravizo.com/svg?@startuml;;Actor "Ich\n(Resource Owner)" as reso;participant "Postman\n(Client)" as client;participant "Github\n(Resource Server)" as ress;participant "Github Auth\n(Authorization Server)" as auth;;reso -> client++ : get repositories;group wenn kein access token vorhanden;client -> auth++ : redirect;auth -> reso++ : bitte einloggen;return username+password;auth -> auth : authentifiziere;auth -> reso++ : Zugriff gewähren für scope "repo"?;return OK;return github-token;end;client -> ress++ : GET /users/gaerfield/repos\nRequest-Header: github-token;return repositories;return repositories;@enduml'/>

</script></section><section data-markdown><script type="text/template">
#### Beispiel Github II

* [Scopes](https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps)

</script></section><section data-markdown><script type="text/template">
### Nächster Schritt

* Kling gut! Wir implementieren OAuth 2
  * Äh ... Nein! Auf gar keinen Fall!

</script></section></section><section ><section data-markdown><script type="text/template">
## s0ft-fits Identity-provider

</script></section><section data-markdown><script type="text/template">
### Warum nicht selber bauen?

* Risiko und Kosten einer eigenen Implementation zu hoch
  * wie Passwörter hashen
  * wie Anwendung skalieren
  * Schutz vor Attacken auf Applikationsebene
  * Schutz gegen Brute-Force und Phishing
  * usw.

</script></section><section data-markdown><script type="text/template">
### Identity Provider

* Authentifikation und Autorisierung sind ein querschnittlicher Belang, entsprechend gibt es fertige Produkte
* on-premise:
  * z.B. Keycloak
  * [zertifizierte OpenId Server](https://openid.net/developers/certified/)
* als Service:
  * (Okta)[https://www.okta.com/de/]
  * (Auth0)[https://auth0.com/de]

</script></section><section data-markdown><script type="text/template">
### login-komponente durch einen Authorization Server ersetzen

on-premise

<img src='https://g.gravizo.com/svg?@startuml;left to right direction;;component webclient;;cloud "s0ft-fit" {;component """--Login--""\n**Authorization Server**" as Login;note right of [Login];erstellt und signiert;Auth-Token (JWT);end note;component "bankdruecken-historie" as his;note right of [his];prüft Signatur;des Auth-Token;;end note;;webclient --> Login: einloggen;webclient --> his : Historie abrufen\nmit JWT im Header;webclient <-- Login : liefert Auth-Token (JWT);;his -> Login : ruft public key ab;};@enduml'/>

</script></section><section data-markdown><script type="text/template">
### login-komponente durch einen Authorization Server ersetzen

servce

<img src='https://g.gravizo.com/svg?@startuml;left to right direction;;component webclient;component """--Login--""\n**Authorization Server**" as Login;note right of [Login];erstellt und signiert;Auth-Token (JWT);end note;;cloud "s0ft-fit" {;component "bankdruecken-historie" as his;note right of [his];prüft Signatur;des Auth-Token;;end note;;webclient --> Login: einloggen;webclient --> his : Historie abrufen\nmit JWT im Header;webclient <-- Login : liefert Auth-Token (JWT);;his -> Login : ruft public key ab;};@enduml'/>

</script></section><section data-markdown><script type="text/template">
### Beispiel Auth0

</script></section></section><section ><section data-markdown><script type="text/template">
## OpenID

</script></section><section data-markdown><script type="text/template">
### neue Anforderung

User sollen sich mit ihren bestehenden Google-Konto oder Github-Konto anmelden können (Single Sign On).

</script></section><section data-markdown><script type="text/template">
### Lösung 1

Wir integrieren alle provider für jede Komponente im Backend:

<img src='https://g.gravizo.com/svg?@startuml;left to right direction;cloud google;cloud github;cloud s0ft-fit {;component login;component "bankdruecken-history" as his;component client;;client --> login : login falls s0ft-fit-account;client --> github : login falls github-account;client --> google : login falls google;;client ---> his : GET /history\nHeader enthält\ngoogle-token || github-token || s0ftfit-token;login <-- his : get public key;google <-- his : get public key;github <-- his : get public key;;his -> his : validiere token je nach typ;};@enduml'/>

</script></section><section data-markdown><script type="text/template">
### Lösung 2 - OpenID Connect

OpenId Connect (OIDC) der aufbauend auf OAuth weitere "claims" definiert und Standard-Endpoints für automatische Discovery:

* Auth0: https://s0ft-fit.eu.auth0.com/.well-known/openid-configuration
* Google: https://accounts.google.com/.well-known/openid-configuration

</script></section><section data-markdown><script type="text/template">
#### grobe Architektur

Im Grunde: wir registrieren s0ft-fit als Drittanwendung in google bzw. github für den Abruf von Profile-Informationen.

<img src='https://g.gravizo.com/svg?@startuml;left to right direction;cloud google;cloud github;cloud s0ft-fit {;component "Identity Provider\n(Auth0)" as login;component "bankdruecken-history" as his;component client;;client --> login : redirect to login;google --> login  : rufe idToken ab;github <-- login  : rufe idToken ab;login --> login : validiere Token;client <-- login : liefere s0ft-fit\nAccess Token;;;login <-- his : rufe public key ab;client --> his : rufe history mit\ns0ft-fit Token ab;his -> his : validiere token je nach typ;};@enduml'/>

</script></section><section data-markdown><script type="text/template">
#### grobe Architektur

<img src='https://g.gravizo.com/svg?@startuml;Actor "Ich\n(Resource Owner)" as reso;participant "Postman\n(Client)" as client;participant "bankdruecken-history\n(Resource Server)" as ress;participant "login\n(Authorization Server)" as auth;participant "github\n(externer Authorization Server)" as gauth;;reso -> client++ : get repositories;group wenn kein access token vorhanden;client -> auth++ : redirect;auth -> reso++ : bitte einloggen\n**oder social login wählen**;return einloggen mit github;auth -> gauth++ : redirect;gauth -> reso++ : bitte einloggen;return username + passwort;gauth -> gauth : authentifiziere;return idtoken;auth -> auth : validiere token;auth -> auth : finde passenden Account\n(oder erstelle neuen);return s0ft-fit Access Token;end;client -> ress++ : GET /history\nRequest-Header: s0ft-fit token;return history;return history;@enduml'/>

## OAuth Flows

</script></section><section data-markdown><script type="text/template">
### Ist der Client auch der Resource Owner?

* Resource Owner ist ein Dienst ist der Zugriff benötigt (bspw. CronJobs)
* keine Nutzer-Authentifizierung notwendig
* M2M-Token
* Client-Id und Client-Secret zur Erlangung eines Access-Tokens

</script></section><section data-markdown><script type="text/template">
### Client Credentials Flow

https://auth0.com/docs/flows/client-credentials-flow

</script></section><section data-markdown><script type="text/template">
### auf dem Server ausgeführte web app

* Access Token wird direkt an den Webserver übermittelt auf dem der client betrieben wird
* kein Risiko des ungewollten Verlusts, weil keine Tokens in den Browser übertragen werden

</script></section><section data-markdown><script type="text/template">
### Authorization Code Flow

https://auth0.com/docs/flows/authorization-code-flow

</script></section><section data-markdown><script type="text/template">
### Is the Client a Single-Page App oder native App?

native apps:
* Client Secrets werden per Client (also per App) ausgestellt
* ist identisch für alle Nutzer und App-Instanzen
* eine native kann das Client Secret nicht sicher speichern
  * Dekompilierung
  * andere Apps können custom URL schemes (bspw. "MyApp://") registrieren und potentiell den redirect zu sich umleiten und den Authorization Code abfangen
* Single Page Apps können das Client Secret nicht sicher verwahren, weil deren gesamter Code im Browser liegt

</script></section><section data-markdown><script type="text/template">
### Authorization Code Flow (PKCE)

* Erweiterung um:
  * ein durch den Client dynamisch erstelltes Secret, der `Code Verifier`
  * eine `Code Challenge` des `Code Verifier`
* Client sendet Code Challenge an den Authorization Server um `Authorization Code` zu erhalten
* `Code Verifier` verbleibt lokal
* mittels `Authorization Code` und `Code Verifier` kann ein Access Token geholt werden
* Attacken können nur den `Authorization Code` abfangen der ungenügend zur Ausstellung von Access Tokens ist

</script></section><section data-markdown><script type="text/template">
### Authorization Code Flow (PKCE)

https://auth0.com/docs/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce

</script></section><section data-markdown><script type="text/template">
### benötigt die WebApp nur ein id Token?

* "normaler" Login nach authorization code flow erfordert das backend ein secret zu verwalten
* die App führt keine Aufrufe an den Resource Server durch und benötigt nur ein Id Token?

</script></section><section data-markdown><script type="text/template">
### Implicit Flow with Form Post

https://auth0.com/docs/flows/implicit-flow-with-form-post

</script></section><section data-markdown><script type="text/template">
### Ist der Client voll vertrauenswürdig?

* Resource Owner Password Flow
  * User und Passwort werden in der Applikation eingetragen
  * evtl. an das Backend übermittelt
* ist **ausschließlich** dann zu verwenden werden, wenn redirect-basierte Flows (bspw. Authorization Code Flow) nicht funktionieren

</script></section><section data-markdown><script type="text/template">
### Resource Owner Password Flow

https://auth0.com/docs/flows/resource-owner-password-flow

## Zusammenfassung

* Client Credentials Flow: für M2M-Szenarien
* Authorization Code Flow (PKCE): für Web und Native Apps
* Resource Owner Password Flow: um Geld bei M2M zu sparen

</script></section></section><section ><section data-markdown><script type="text/template">
## Zusammenfassung

* Java Web Tokens erlauben in verteilten Systemen den Austausch verifizierbarer Informationen
* OAuth ermöglicht es Nutzern den Zugriff auf die eigenen Daten für Drittanwendungen zu steuern (ohne das Passwort weitergeben zu müssen)
* OpenId ermöglicht es Logins wiederzuverwenden

</script></section><section data-markdown><script type="text/template">
## Fazit

* Authentifizierung und Autorisierung ist eine klassische querschnittliche Aufgabe (wie Logging, Tracing)
* entsprechend sollten diese Aufgaben von der Domäne getrennt werden
* OAuth 2.0 und OpenID Connect bieten einen Standad diese Trennung in der eigenen Applikation sicherzustellen
* positive Seiteneffekte:
  * Entwicklung des Backends vereinfacht sich, da nur auf entsprechende Scopes im Access-Token geprüft werden muss
  * die Zukunftssicherheit der Applikation erhöht sich, da diese sich leichter mit weiteren Anwendungen integrieren kann
  * die Implementierung einer eigenen Lösung ist unnötig risiko-behaftet, stattdessen bestehende Systeme einsetzen

* die Implementation einer Authentifizierung ist nach meiner Erfahrung schon immer kompliziert gewesen, selbst in Monolithen:
  * User Datenbank muss gepflegt werden
  * Rollen und Gruppen müssen verwaltet werden
  * etc.
* selbst wenn keine Anforderung für Social Logins oder Zugriffserlaubnis für Drittanwendungen besteht, ist der Einsatz eines Identity-Providers zu bevorzugen (sei es on-premise oder service):
  * Implementationskosten verlagern sich auf Konfigurationskosten
  * Verringerung der Anwendungskomplexität:
    * das Backend muss nichts über Authentifikation wissen
    * alle relevanten Informationen sind im Token enthalten
    * oder können beim Identity Provider abgefragt werden
  * Betriebskosten sind identisch oder geringer
  * geringere Sicherheitsrisiken
  * erzwingt sinvollere Architektur durch Trennung von Verantwortlichkeiten über standardisierte Schnittstellen

</script></section><section data-markdown><script type="text/template">
## Fazit

Bloß nicht selber implementieren!

###  Links

* https://openidconnect.net/

dieses mal mit openid

</script></section></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":false,"slideNumber":false,"transition":"slide","backgroundTransition":"fade"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
