<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md deployed to gh-pages</title>
    <link rel="shortcut icon" href="./favicon.ico"/>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/solarized.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./_assets/custom.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

# dezentrale Authentifizierung mit OAuth 2

</script></section><section ><section data-markdown><script type="text/template">
## Ziel

Dezentrales Authentifizierungssystem für webbasierte Dienste.

* OAuth als Protokoll zur Authentifizierung für die Autorisierung von Zugriffsrechten zwischen zwei Applikationen
* OpenID Connect aufbauend auf OAuth erlaubt die Wiederverwendung desselben Logins für verschiedene Applikationen (Single-Sign-On) und den standardisierten Abruf von Profilinformationen

</script></section><section data-markdown><script type="text/template">
## Geschichte

* 2005 OpenID Vorstellung des offenen Single-Sign-On Protokolls
* 2006 Entwicklung von OAuth 1.0 während der Integration von OpenID in Twitter (Delegation der Authentifizierung)
* 2007 Vortstellung von OAuth 1.0
* Juni 2007 Gründung der OpenID Foundation zur Sicherung von Markenrechten
* Dezember 2007 OpenID 2.0
* November 2008 Vorschlag an die IETF zur Standardisierung von OAuth
* 2012 OAuth 2 durch die IETF als RFC 6749 und RFC 6750 veröffentlicht.
* irgendwann OpenID Connect als Schicht oberhalb des OAuth Protokolls

</script></section><section data-markdown><script type="text/template">
## Startup s0ftf1t

Fitnessstudio-Startup mit online Training-Tracker:
* gehe Trainieren wann immer du willst
* rufe deine Trainings-Historie ab wann immer du willst

</script></section><section data-markdown><script type="text/template">
### Architektur

<img src='https://g.gravizo.com/svg?@startuml;component "s0ft-fit.de";@enduml'/>

### Typischer Flow der Authentifizierung
<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "server";user -> webclient++ : login bei "s0ft-fit.de";webclient -> server++ : login;server -> server : validiere;return ok;return willkommen;@enduml'/>

## Modularisierung von s0ftf1t

</script></section></section><section ><section data-markdown><script type="text/template">
### Problemstellung

* skalierung von einem Fitnessstudio auf tausende
* Login und Historie sind unterschiedlich stark frequentiert und sollen unabhängig skalieren um Ressourcen zu sparen
* Wie autorisieren wir Nutzer zum Abruf seiner Daten?
  * Klasssicher Ansatz: sessionIds

</script></section><section data-markdown><script type="text/template">
#### Login

<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "login";database "session-management" as ses;;user -> webclient++ : login bei "s0ftf1t.de";webclient -> login++ : login;login -> login : validiere;login -> ses++ : loggedIn(User);ses -> ses : lege session an und speichere User;return sessionId;return sessionId;return willkommen;@enduml'/>

</script></section><section data-markdown><script type="text/template">
#### Abruf der Historie

<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "bankdruecken-historie" as his;database "session-management" as ses;;user -> webclient++ : Klick auf Historie;webclient -> his++ : getFor(sessionId);his -> ses++ : getUserForSession(sessionId);return User;his -> his : getFor(User);return history;return tabelle;@enduml'/>

</script></section><section data-markdown><script type="text/template">
#### Abruf der Historie

* Sessions funktionieren gut für Warenkörbe (da session-Informationen verändert werden)
* ein Login ändert sich aber nicht, warum nicht direkt die Informationen teilen?

</script></section><section data-markdown><script type="text/template">
### Token

<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "login";participant "bankdruecken-historie" as his;;user -> webclient++ : login bei "s0ftf1t.de";webclient -> login++ : login;login -> login : validiere;return User=Achim;return willkommen;...;user -> webclient++ : Klick auf Historie;webclient -> his++ : getFor(user = Achim);return history;return tabelle;@enduml'/>

</script></section><section data-markdown><script type="text/template">
#### JWT

* Wie sicherstellen, dass das Token nicht verändert wurde?
* JSON Web Token
* Aussprache: JOT
* Standard zum Austausch von **verifizierbaren** Informationen

</script></section><section data-markdown><script type="text/template">
#### JWT

* Aufbau eines JWT-Token: "base64(Header).base64(Payload).signature"
  * Header: unter anderem den Signatur-Algorithmus
  * Payload: sog. "Claims", die verifizierbaren Entitäten
  * Signatur: hash des Klartexts aus header und payload entsprechend des im Header angegebenen Algorithmus
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```
JWT.io


### JWT

<img src='https://g.gravizo.com/svg?@startuml;actor user;participant "webclient";participant "login";participant "bankdruecken-historie" as his;;user -> webclient++ : login bei "s0ftf1t.de";webclient -> login++ : login;login -> login : validiere;login -> login : erzeuge JWT;login -> login : signiere JWT mittels\nprivate login-private-Key;return --User-- **JWT**;return willkommen;...;user -> webclient++ : Klick auf Historie;webclient -> his++ : getFor(--User-- **JWT**);his -> his : validiere Signatur mittels\nlogin-public-key;return history;return tabelle;@enduml'/>

### Fazit

In einem verteilten System ist eine zentrale Authentifikations-Instanz welche JWT-Tokens ausstellt hinreichend.

<img src='https://g.gravizo.com/svg?@startuml;left to right direction;;cloud "s0ftf1t" {;component Login;note right of [Login];erstellt und signiert;Auth-Token (JWT);end note;component "bankdruecken-historie" as his;note right of [Login];prüft Signatur des Auth-Token;end note;component webclient;;webclient --> Login: einloggen;webclient --> his : Historie abrufen\nmit JWT im Header;webclient <-- Login : liefert Auth-Token (JWT);;his -> Login : ruft public key ab;};;;;@enduml'/>

</script></section></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":false,"slideNumber":false,"transition":"slide","backgroundTransition":"fade"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
